% LaTeX Template für Abgaben an der Universität Stuttgart
% Autor: Sandro Speth
% Bei Fragen: Sandro.Speth@iste.uni-stuttgart.de
%-----------------------------------------------------------
% Hauptmodul des Templates: Hier können andere Dateien eingebunden werden
% oder Inhalte direkt rein geschrieben werden.
% Kompiliere dieses Modul um eine PDF zu erzeugen.

% Dokumentenart. Ersetze 12pt, falls die Schriftgröße anzupassen ist.
\documentclass[12pt]{scrartcl}
% Einbinden der Pakete, des Headers und der Formatierung.
% Mit den \include und \input Befehlen können Dateien eingebunden werden:
% \include: Fügt einen Seitenumbruch nach dem Text ein
% \input: Fügt KEINEN Seitenumbruch nach dem Text ein
\input{../assets/Packages.tex}
\input{../assets/FormatAndHeader.tex}

\setcounter{exnum}{1} % Nummer der Aufgabe

\begin{document}

\input{../assets/Titelseite.tex} % Titelseite einbinden

% Nutze den \exercise{Aufgabenname} Befehl, um eine neue Aufgabe zu beginnen.
% Möchtest du eine Aufgabe in der Nummerierung überspringen, schreibe vor der Aufgabe: \stepcounter{exnum}
% Möchtest du die Nummer einer Aufgabe auf eine beliebige Zahl x setzen, schreibe vor der Aufgabe: \setcounter{exnum}{x}

% Aufgabe 1
\exercise{Kritischer Pfad}

\begin{enumerate}
  \item[a)] ~
        \begin{figure}[h]
          \centering
          \includegraphics[width=1.0\textwidth]{./Tex-Graphics/Aufgabe1a.png}
          \caption{Instanz der CPM}
        \end{figure}
  \item[c)] Der verwendete Algorithmus besteht im westentlichen aus zwei Phasen. In der ersten Phase, der Forward-Propagation, werden zunächst die Startknoten identifiziert. Dies sind alle Knoten ohne Abhängigkeiten. Für diese wird dann $EF$ als $ES+duration$ berechnet. Diese neue Informationen werden an alle Knoten mit direkten Abhängigkeiten weitergegeben. Dies wiederholt sich rekursiv, bis alle Knoten den Zeitpunkt $EF$ erhalten haben. In der darauf folgenden zweiten Phase wird die Gesamtdauer des Projekt als Maximum aller $EF$ berechnet und als $LF$ aller Knoten ohne Nachfolger (Blattknoten) gesetzt. Daraus ergibt sich für alle Blattknoten der $LS$ als $LF-duration$. Diese Informationen werden dann an die Eltern (alle Knoten von denen der aktuelle Knoten abhängt) rekursiv weitergegeben, bis schlussendlich alle Knoten $ES,EF,LS,LF$ ermittelt haben. Zum Schluss wird für jeden Knoten der Slack als $LS-ES = LF-EF$ berechnet.
        \\
        Um die Arbeitspakete und ihre Abhängigkeiten zu modellieren, haben wir uns für ein objektorientiertes Design entschieden. Dies hat für die Softwarequalität den Vorteil, dass die Kapselung von Daten und Methoden in einer Klasse eine hohe Kohäsion und geringe Kopplung fördert. Jede Instanz der Klasse \texttt{Package} modelliert dabei ein Arbeitspaket mit seinen Eigenschaften (Dauer, ES, EF, LS, LF, Slack) und Methoden zur Berechnung dieser Eigenschaften. Die Abhängigkeiten zwischen den Arbeitspaketen werden durch Referenzen auf IDs anderer \texttt{Package}-Objekte modelliert. Die gesamte Menge der Arbeitspakete wird in einer \texttt{CriticalPathFinder}-Klasse verwaltet, die die Logik für die Durchführung der Forward- und Backward-Propagation implementiert. Diese Struktur ermöglicht eine klare Trennung der Verantwortlichkeiten und erleichtert die Wartung und Erweiterung des Codes.
\end{enumerate}
\exercise{Bowling Game Kata}
Die Berechnung des Scores erfolgt indem man die Summe aller Frames bildet. Der Score eines Frames besteht dabei aus einem Base-Score, welcher lediglich die umgeworfenen Pins pro Frame angibt. Der Bonus-Score bildet die Extra-Punkt ab, die man durch das erzielen eines Strikes oder Spares erhält. Der Score eines Frames ist somit die Summe aus Base-Score und Bonus-Score.\\
Für einen einzelnen Roll wurde die Datenstruktur eines record gewählt, da ein Roll unveränderlich sein soll. (Man soll im Nachhinein nicht seine geworfenen Punkte manipulieren können). Um eine gute Wartbarkeit zu gewährleisten, wurde versucht konsuquent Konstanten einzuführen, anstatt Werte zu hardcoden. Dies hat den Effekt einer guten Wartbarkeit. Sollten zum Beispiel drei Rolls pro Frame erlaubt sein, so muss man nur eine  einzige Stelle im Code ändern, um die Regeländerung zu implementieren.

\exercise{Game of Life Kata}
Wir haben uns dazu entschieden, einen 2D-Array für das GameBoard zu verwenden, wobei hier die einzelnen Einträge aus einer GameCell bestehen, die mithilfe eines \texttt{bool} den Lebendigkeitsstatus der Zelle repräsentiert. Für die Nachbarzellen haben wir eine \texttt{coordinate offset mask} eingeführt, die uns die schnelle Berechnung aller Nachbarn für eine gegebene Zelle ermöglicht. Ein weiterer wichtiger Faktor war die Einführung eines GameBoard Buffers, sodass wir gesetzte Zellen vom Nutzer von denen innerhalb der Berechnung für die nächste Generation unterscheiden können. Wir beziehen uns hierbei immer auf den \textbf{Ist}-Zustand von unserem aktiven Board und berechnen die nächste Generation im Buffer, sodass keine kaskadierenden Effekte entstehen. Die Tests wurden so aufgebaut, dass wir die geltenden Regeln für Conways Game of Life in einzelnen Testmethoden festgelegt haben und diese dann mittels TDD implementiert haben.

\end{document}