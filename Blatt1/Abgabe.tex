% LaTeX Template für Abgaben an der Universität Stuttgart
% Autor: Sandro Speth
% Bei Fragen: Sandro.Speth@iste.uni-stuttgart.de
%-----------------------------------------------------------
% Hauptmodul des Templates: Hier können andere Dateien eingebunden werden
% oder Inhalte direkt rein geschrieben werden.
% Kompiliere dieses Modul um eine PDF zu erzeugen.

% Dokumentenart. Ersetze 12pt, falls die Schriftgröße anzupassen ist.
\documentclass[12pt]{scrartcl}
% Einbinden der Pakete, des Headers und der Formatierung.
% Mit den \include und \input Befehlen können Dateien eingebunden werden:
% \include: Fügt einen Seitenumbruch nach dem Text ein
% \input: Fügt KEINEN Seitenumbruch nach dem Text ein
\input{../assets/Packages.tex}
\input{../assets/FormatAndHeader.tex}

\setcounter{exnum}{1} % Nummer der Aufgabe

\begin{document}

\input{../assets/Titelseite.tex} % Titelseite einbinden

% Nutze den \exercise{Aufgabenname} Befehl, um eine neue Aufgabe zu beginnen.
% Möchtest du eine Aufgabe in der Nummerierung überspringen, schreibe vor der Aufgabe: \stepcounter{exnum}
% Möchtest du die Nummer einer Aufgabe auf eine beliebige Zahl x setzen, schreibe vor der Aufgabe: \setcounter{exnum}{x}

% Aufgabe 1
\exercise{Kritischer Pfad}

\begin{enumerate}
  \item[a)] ~
        \begin{figure}[h]
          \centering
          \includegraphics[width=1.0\textwidth]{./Tex-Graphics/Aufgabe1a.png}
          \caption{Instanz der CPM}
        \end{figure}
  \item[c)] Der verwendete Algorithmus besteht im westentlichen aus zwei Phasen. In der ersten Phase, der Forward-Propagation, werden zunächst die Startknoten identifiziert. Dies sind alle Knoten ohne Abhängigkeiten. Für diese wird dann $EF$ als $ES+duration$ berechnet. Diese neue Informationen werden an alle Knoten mit direkten Abhängigkeiten weitergegeben. Dies wiederholt sich rekursiv, bis alle Knoten den Zeitpunkt $EF$ erhalten haben. In der darauf folgenden zweiten Phase wird die Gesamtdauer des Projekt als Maximum aller $EF$ berechnet und als $LF$ aller Knoten ohne Nachfolger (Blattknoten) gesetzt. Daraus ergibt sich für alle Blattknoten der $LS$ als $LF-duration$. Diese Informationen werden dann an die Eltern (alle Knoten von denen der aktuelle Knoten abhängt) rekursiv weitergegeben, bis schlussendlich alle Knoten $ES,EF,LS,LF$ ermittelt haben. Zum Schluss wird für jeden Knoten der Slack als $LS-ES = LF-EF$ berechnet.
        \\
        Um die Arbeitspakete und ihre Abhängigkeiten zu modellieren, haben wir uns für ein objektorientiertes Design entschieden. Dies hat für die Softwarequalität den Vorteil, dass die Kapselung von Daten und Methoden in einer Klasse eine hohe Kohäsion und geringe Kopplung fördert. Jede Instanz der Klasse \texttt{Package} modelliert dabei ein Arbeitspaket mit seinen Eigenschaften (Dauer, ES, EF, LS, LF, Slack) und Methoden zur Berechnung dieser Eigenschaften. Die Abhängigkeiten zwischen den Arbeitspaketen werden durch Referenzen auf IDs anderer \texttt{Package}-Objekte modelliert. Die gesamte Menge der Arbeitspakete wird in einer \texttt{CriticalPathFinder}-Klasse verwaltet, die die Logik für die Durchführung der Forward- und Backward-Propagation implementiert. Diese Struktur ermöglicht eine klare Trennung der Verantwortlichkeiten und erleichtert die Wartung und Erweiterung des Codes.
\end{enumerate}
\exercise{Bowling Game Kata}

Der Algorithmus zur Berechnung des Scores erfolgt über jeden Frame einzeln. Jeder Frame enthält dabei den geworfenen Score des Frames und welcher Frame der folgende Frame ist. Auf dieser Basis lässt sich dann der Score des Frames und die Bonuspunkte errechnen (bei Strike wird aus dem nächsten Frame der basis score entnommen, da dieser im Standard Spiel der Anzahl der regulären Würfe entspricht, falls im folgenden Frame ein Strike auftrat wird im darauf folgenden Frame (sofern vorhanden) der erste Wurf noch addiert. Bei einem Spare nur der erste Wurf im folgenden Frame sofern vorhanden).

Es wurde sich für einen Array an Frames entschieden da dieser schnelle Zugriffszeiten erlaubt, leicht indizierbar ist und es bei einem Bowlingspiel nicht wichtig ist, dass er wachsen kann, die Größe wird direkt beim Start festgelegt und wird während des Spiels nicht verändert.

Für einen einzelnen Roll wurde die Datenstruktur eines Records gewählt, ein Roll ist unveränderlich nachdem er geworfen wurde und daher eignet sich ein Record optimal.

Für die Rolls in einem Frame wurde eine ArrayList gewählt da diese es einfach erlaubt die länge abzufragen um daraufhin zu validieren, dass noch Würfe gemacht werden dürfen.

Um eine gute Wartbarkeit zu gewährleisten, wurden Konstanten eingeführt die bspw. die maximale Anzahl der Pins, der Frames oder der regulären Würfe beschreiben. Dies hat den Effekt, dass zum Beispiel leicht auf drei Rolls pro Frame oder ein kurzes Spiel über die maximale Anzahl der Frames gewechselt werden kann, so muss man nur eine einzige Stelle im Code ändern, um die Regeländerung zu implementieren.

\exercise{Game of Life Kata}
Wir haben uns dazu entschieden, einen 2D-Array für das GameBoard zu verwenden, wobei hier die einzelnen Einträge aus einer GameCell bestehen, die mithilfe eines \texttt{bool} den Lebendigkeitsstatus der Zelle repräsentiert. Für die Nachbarzellen haben wir eine \texttt{coordinate offset mask} eingeführt, die uns die schnelle Berechnung aller Nachbarn für eine gegebene Zelle ermöglicht. Ein weiterer wichtiger Faktor war die Einführung eines GameBoard Buffers, sodass wir gesetzte Zellen vom Nutzer von denen innerhalb der Berechnung für die nächste Generation unterscheiden können. Wir beziehen uns hierbei immer auf den \textbf{Ist}-Zustand von unserem aktiven Board und berechnen die nächste Generation im Buffer, sodass keine kaskadierenden Effekte entstehen. Die Tests wurden so aufgebaut, dass wir die geltenden Regeln für Conways Game of Life in einzelnen Testmethoden festgelegt haben und diese dann mittels TDD implementiert haben.

\end{document}