% LaTeX Template für Abgaben an der Universität Stuttgart
% Autor: Sandro Speth
% Bei Fragen: Sandro.Speth@iste.uni-stuttgart.de
%-----------------------------------------------------------
% Hauptmodul des Templates: Hier können andere Dateien eingebunden werden
% oder Inhalte direkt rein geschrieben werden.
% Kompiliere dieses Modul um eine PDF zu erzeugen.

% Dokumentenart. Ersetze 12pt, falls die Schriftgröße anzupassen ist.
\documentclass[12pt]{scrartcl}
% Einbinden der Pakete, des Headers und der Formatierung.
% Mit den \include und \input Befehlen können Dateien eingebunden werden:
% \include: Fügt einen Seitenumbruch nach dem Text ein
% \input: Fügt KEINEN Seitenumbruch nach dem Text ein
\input{../assets/Packages.tex}
\input{../assets/FormatAndHeader.tex}
\hbadness=99999 % No fucking underfull hbox warning
\hfuzz=9999pt % No fucking overfull hbox warning
\usetikzlibrary{arrows.meta, positioning, calc, shapes.geometric}
\renewcommand{\arraystretch}{1.5}
\newcommand{\textarrow}[1]{%
    \tikz[baseline, inner sep=0pt] {
        % 1. Create a hidden node with the text to measure width
        \node[anchor=south, font=\scriptsize, align=center, inner ysep=2pt] (txt) at (0,0) {#1};
        % 2. Draw the arrow underneath it
        \draw[->, >=Latex, thick, rounded corners]
             ($(txt.south west)$) -- ($(txt.south east) + (3mm, 0)$);
    }%
}

\setcounter{exnum}{1} % Nummer der Aufgabe

\begin{document}
\input{../assets/Titelseite.tex} % Titelseite einbinden
\section*{Integrationsteststrategien}
\begin{enumerate}[label=\alph*)]
  \item ~\\ \begin{tabular}{|c||c|c|c|c|c|}
          \hline
          \# & A                  & B                   & D                   & C                   & E                   \\
          \hline\hline
          1  & \textcolor{red}{A} & \textcolor{blue}{b} &                     & \textcolor{blue}{c} &                     \\
          \hline
          2  & A                  & \textcolor{red}{B}  & \textcolor{blue}{d} & \textcolor{blue}{c} & \textcolor{blue}{e} \\
          \hline
          3  & A                  & B                   & \textcolor{red}{D}  & \textcolor{blue}{c} & \textcolor{blue}{e} \\
          \hline
          4  & A                  & B                   & D                   & \textcolor{red}{C}  & \textcolor{blue}{e} \\
          \hline
          5  & A                  & B                   & D                   & C                   & \textcolor{red}{E}  \\
          \hline
        \end{tabular} \\\\
        \underline{Legende:} \\
        \textcolor{red}{Integrierte Komponente}, \textcolor{blue}{Platzhalter (Stubs)} \\ \\
        \underline{Ausführliche Beschreibung:} \\
        Da es Top-Down ist, fangen wir oben bei Web-UI (A) an. Diese Komponente wird integriert. Dadurch müssen wir zwei Stubs einfügen (Platzhalter). Einmal für B und einmal für C. Dann gehen wir weiter zu B. Hier wird dann B integriert und es müssen zwei weitere Stubs für D und E eingefügt werden. Danach wird D integriert, welches keine weiteren Auswirkungen hat. Danach wird C integriert, hier würde man nochmal ein Stub für E einfügen, dieser hat aber schon einen Stub, also brauchen wir nicht erneut einen. Zum Schluss wird E integriert, welches das Ende ist und auch keine weiteren Auswirkungen hat. Einen Treiber braucht man hier nicht, da z.B. B hier D und E aufrufen möchte, aber diese noch gar nicht integriert sind, und deshalb durch einen Platzhalter ersetzt werden, die so tun als wären sie z.B. D oder E. Ein Treiber wäre nur nötig wenn man z.B. E testen wollen würde, aber noch niemand der E überhaupt ausführen könnte. Siehe Teilaufgabe $b)$.
  \item ~\\ \begin{tabular}{|c||c|c|c|c|c|}
          \hline
          \# & A                  & B                  & C                  & D                  & E                  \\
          \hline\hline
          1  &                    &                    &                    &                    & \textcolor{red}{E} \\
          \hline
          2  &                    &                    &                    & \textcolor{red}{D} & E                  \\
          \hline
          3  &                    &                    & \textcolor{red}{C} & D                  & E                  \\
          \hline
          4  &                    & \textcolor{red}{B} & C                  & D                  & E                  \\
          \hline
          5  & \textcolor{red}{A} & B                  & D                  & C                  & E                  \\
          \hline
        \end{tabular} \\\\
        \underline{Legende:} \\
        \textcolor{red}{Integrierte Komponente}\\ \\
        \underline{Ausführliche Beschreibung:} \\
        Hier fangen wir unten an, nämlich bei E. Wir integrieren E und brauchen für E einen Treiber, da B und C noch nicht existieren und wir aber E aufrufen wollen. Danach integrieren wir D, hierfür brauchen wir auch einen Treiber, da B noch nicht existiert. Danach integrieren wir C, hierfür brauchen wir auch wieder einen Treiber, da A noch nicht existiert. Als nächstes integrieren wir B, hierfür brauchen wir auch einen Treiber, da A noch nicht existiert. Zum Schluss integrieren wir A, welches das Ende ist und keinen Treiber mehr braucht, da es ganz oben in der Hierarchie ist. Stubs werden hier nicht benötigt, da immer die abhängigen Komponenten schon integriert sind, wenn eine Komponente integriert wird.
  \item Wir würden eine Bottom-Up-Strategie (BUS) benutzen. D gilt als technisch anfällig, die BUS beginnt mit den untersten Modulen. Komponente D würde also sehr weit am Anfang getestet werden. Man könnte hier sogar schon in Schritt 1 anfangen D zu testen und danach erst E ausführen. Fehler werden also hier am frühesten gefunden. Bei der Top-Down-Strategie (TDS) wäre D erst sehr spät an der Reihe, was widerrum das Risiko erhöht. Wegen der Testumgebung, also A ist massiv im Verzug, ist es für die TDS die Komponente A zwingend als Startpunkt erforderlich, was schlecht ist, da man ohne A nicht mit der Integration überhaupt beginnen kann. BUS hingegen, braucht A erst sehr spät (nämlich im letzten Schritt). Die Entwicklung und Integration vom Backend kann also einfach wietergehen.
\end{enumerate}
\newpage
\section*{Statische Code-Analyse und Datenflussanomalien}
\begin{enumerate}[label=\alph*)]
  \item ~\\ \begin{tabular}{cc}
          \begin{tabular}{|c|c|c c c c|}
            \hline
            \diagbox{Zeile}{Pfad}
               & $n<0: n_{1}n_{5}n_{8}n_{13}$ \\
            \hline \hline
            1  & u                            \\
            \hline
            5  & d                            \\
            \hline
            8  & d                            \\
            \hline
            10 &                              \\
            \hline
            13 & r                            \\
            \hline
          \end{tabular}  &
          \begin{tabular}{|c|c|c c c c|}
            \hline
            \diagbox{Zeile}{Pfad}
               & $n=0: n_{1}n_{8}n_{13}$ \\
            \hline \hline
            1  & u                       \\
            \hline
            5  &                         \\
            \hline
            8  & d                       \\
            \hline
            10 &                         \\
            \hline
            13 & r                       \\
            \hline
          \end{tabular}       \\\\
          \begin{tabular}{|c|c|c c c c|}
            \hline
            \diagbox{Zeile}{Pfad}
               & $n=1: n_{1}n_{8}n_{10}n_{13}$ \\
            \hline \hline
            1  & u                             \\
            \hline
            5  &                               \\
            \hline
            8  & d                             \\
            \hline
            10 & r,d                           \\
            \hline
            13 & r                             \\
            \hline
          \end{tabular} &
          \begin{tabular}{|c|c|c c c c|}
            \hline
            \diagbox{Zeile}{Pfad}
               & $n=2: n_{1}n_{8}n_{10}n_{10}n_{13}$ \\
            \hline \hline
            1  & u                                   \\
            \hline
            5  &                                     \\
            \hline
            8  & d                                   \\
            \hline
            10 & r,d                                 \\
            \hline
            10 & r,d                                 \\
            \hline
            13 & r                                   \\
            \hline
          \end{tabular}
        \end{tabular} \\\\
        Wenn wir jetzt unsere Ergebnisse zusammentragen, kommen wir auf folgende Tabelle, die uns die Analyse für die Variable $ergebnis$ zeigt: \\
        \begin{tabular}{|c|c|c|p{8cm}|}
          \hline
          Zeile & Aktion auf $ergebnis$ & Status nach Zeile & Anmerkung                                      \\
          \hline \hline
          START & -                     & u                 & Startzustand alle Variablen auf u              \\
          \hline
          1     & -                     & u                 & $ergebnis$ nicht betroffen. Import von $n$     \\
          \hline
          2     & -                     & u                 & Deklaration von $ergebnis$                     \\
          \hline
          3     & -                     & u                 & $ergebnis$ nicht betroffen                     \\
          \hline
          4     & -                     & u                 & $ergebnis$ nicht betroffen                     \\
          \hline
          5     & d                     & d                 & Erste Definition, $ergebnis$ erhält Wert 0     \\
          \hline
          6     & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          7     & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          8     & d                     & d                 & Zweite Definition, $ergebnis$ erhält Wert 1    \\
          \hline
          9     & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          10    & r, d                  & d                 & $ergebnis$ wird gelesen und neu zugewiesen     \\
          \hline
          11    & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          12    & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          13    & r                     & d                 & Referenzierung, $ergebnis$ Wert wird gelesen   \\
          \hline
          14    & -                     & d                 & $ergebnis$ nicht betroffen                     \\
          \hline
          END   & -                     & u                 & Out of scope deshalb $ergebnis$ = u            \\
          \hline
        \end{tabular} \\\\
        \underline{Anomalie:} \\
        Im ersten Pfad also der Pfad für $n~<~0$ entsteht durch die Zeilen 5 (erstes $d$) und 8 (zweited $d$ ohne ein $r$ dazwischen) eine $d-d$ Anomalie. Beide Zeilen weisen der Variable einen Wert zu, ohne dass diese zwischen den Zeilen referenziert wurden.

  \item Die gefundene $d-d$ Anomalie aus $a)$ führt für die Berechnung der Fakultät zu einem Bug. In Zeile 5 wird $ergebnis$ innerhalb des if-Blocks auf 0 gesetzt. Das ist wahrscheinlich von dem Entwickler so gewollt um negative Inputs so immer auf 0 zu setzen. Jedoch wird in Zeile 8 $ergebnis$ bedingungslos auf 1 gesetzt. D.h. der Wert der vorher beabsichtigt vom Entwickler auf 0 gesetzt wurde, wird einfach immer überschrieben. Das führt dazu, dass die vom Entwickler eingebaute Sonderbehandlung der negativen Inputs einfach entfällt. In Zeile 9 ist es auch so dass die while Schleife in dem Case wenn $n$ negativ ist, nie betreten wird, da $i$ auf 0 gesetzt wird und $n$ negativ ist.
  \item Der Input $-1$ führt mit der gefundenen $d-d$ Anomalie aus $a)$ zu einem grundlegenden Fehler. Die Fakultätsfunktion ist nämlich für negative Inputs nicht definiert. In Zeile 4 hat der Entwickler eindeutig eine solche Abfrage eingebaut und auch dann weiter behandelt in Zeile 5 und diese auf 0 gesetzt. Wie vorher schon beschrieben wird dann in Zeile 8 der Wert für $ergebnis$ immer auf 1 gesetzt, was mathematisch und systematisch nicht korrekt ist, da die Schleife für negative Inputs nicht betreten wird. Das Programm ignoriert also seine eigene Logik und Fehlerbehandlung für negative Inputs komplett und gibt immer 1 aus, obwohl die Code-Intention in Zeile 5 0 erwarten würde. Somit ist das Ergebnis für den Input $-1$ mit der Anomalie 1, was falsch ist. Korrekt wäre hier 0 oder eine Exception, damit man damit richtig weiterarbeiten kann. Das hat vor allem Auswirkungen auf die Zuverlässigkeit und Korrektheit des Programms und auch für die weiterführenden Programme die diese Funktion aufrufen und dann auf einer falschen Grundlage weiterarbeiten. Zudem ist hier das Prinzip des Design by Contract sehr wichtig, denn die volle Verantwortung für die Korrektheit liegt beim Aufrufer. Heißt also wenn wir hier eine Precondition hätten, die sagt dass keine negativen Werte initialisiert werden dürfen, liegt die Verantwortung beim Aufrufer. Wenn diese Bedingung eingehalten wird, wäre dann der Code den der Entwickler geschrieben hat für den Case $n<0$ gar nicht erreichbar und toter Code.
  \end{enumerate}
\section*{Code Metriken in der Praxis}
\begin{enumerate}[label=\alph*)]
  \item \begin{lstlisting}
    /**
    * An listener which listens for state changes in any of the incoming
    * places. Used to signal when to fire this transition.
    */
    private final Observer incomingPlacesObserver = new Observer() {

        /*
         * (non-Javadoc)
         *
         * @see java.util.Observer#update(java.util.Observable,
         * java.lang.Object)
         */
        public void update(final Observable observable, final Object arg) {
            TokenCountChangedEvent event = (TokenCountChangedEvent) arg;
            int newNoOfOccupiedPlaces;
            if (event.placeBecameEmpty()) {
                newNoOfOccupiedPlaces = noOfOccupiedIncomingPlaces
                        .decrementAndGet();
            } else {
                if (event.placeBecameOccupied()) {
                  newNoOfOccupiedPlaces = noOfOccupiedIncomingPlaces
                            .incrementAndGet();
                            } else {
                    newNoOfOccupiedPlaces = noOfOccupiedIncomingPlaces.get();
                    }
                    }
                    unblockIfEnoughTokensAvailable(
                      newNoOfOccupiedPlaces);
        }
    };
\end{lstlisting}
        Hier sieht man schnell dass es insgesamt 2 If-Blöcke gibt. Einmal in Zeile 16 und einmal in Zeile 20. Wir Starten mit dem Startwert 1, hier weden jetzt die 2 möglichen Pfade der If-Blöcke hinzugefügt mit jeweils ++. Somit entsteht folgende Berechnung für die zyklomatische Komplexität $M$ mit Entscheidungswegen $E$:
        \begin{align*}
          M & = E + 1     \\
          M & = 2 + 1 = 3
        \end{align*}
        \begin{lstlisting}
  /**
     * Tries to fire this transition. It blocks until enough tokens are
     * available and then tries to grab all locks of all incoming places. If
     * successful, checks again whether it is still allowed to fire. If so, it
     * fires.
     * @throws InterruptedException thrown if an interrupt was requested
     */
     private void fire() throws InterruptedException {
        blockUntilEnoughTokensAvailable();
        if (lockAndCheckIncomingPlaces()) {
            setChanged();
            notifyObservers(new TransitionStartsToFireEvent());
            for (Place incommingPlace : incomingPlaces) {
              incommingPlace.decrementTokenCount();
            }
            for (Place outgoingPlace : outgoingPlaces) {
              outgoingPlace.incrementTokenCount();
              }
              setChanged();
              notifyObservers(new TransitionEndsFireEvent());
              unlockLockedPlaces(incomingPlaces);
              }
    }
  \end{lstlisting}
        Auch hier sieht man schnell dass es einn If-Block gibt in Zeile 10. In diesem werden dann nochmals zwei for-Schleifen (Zeile 13 und 16) eingebaut was die Komplexität erhöht. Diese muss man beide mit einrechnen also auch jeweils ++. Somit entsteht folgende Berechnung für die zyklomatische Komplexität $M$ mit Entscheidungswegen $E$:
        \begin{align*}
          M & = E + 1     \\
          M & = 3 + 1 = 4
        \end{align*}
  \item Wir haben uns hier für diese Teilaufgabe für das Plugin Checkstyle in IntelliJ entschieden. Zudem haben wir für die Configuration Files Google Checks verwendet wie man im nachfolgenden Screenshot entnehmen kann. Nachdem wir das Checkstyle Plugin laufen lassen haben, sind insgesamt 116 Warnungen aufgetreten. Man kann hier leider nicht nach Metriken und Hotspots sortieren oder filtern, deshalb haben wir uns alle Meldungen angeschaut und die relevantesten für diese Teilaufgabe herausgesucht und zusammengefasst. \\ \\
        Man kann schon mal direkt sagen dass die Code-Qualität nicht im akzeptablen Bereich liegt. Es ist sehr offensichtlich dass so viele Meldungen nicht akzeptabel sind. Es gibt massive Verletzungen der Coding-Standards von Google Checks welche wir verwendet haben. Falsche Einrückung, fehlende Dokumentation und Import-Fehler.
        \begin{center}
          \includegraphics[width=0.95\textwidth]{Tex-Graphics/Aufgabe3-b-116-Warnings.jpg}
        \end{center}
        \underline{1. Hotspot: Einrückungen}\\
        \includegraphics[width=0.95\textwidth]{Tex-Graphics/Aufgabe3-b-fire.jpg}
        Die Liste zeigt sehr hohe Anzahl an Einrückungstiefen, z.B. in Zeile 212, 214, 215 usw.. Das korreliert natürlich mit der Verschachtelungstiefe und das weißt auch auf eine hohe Komplexität hin (Das wir nochmal in Teilaufgabe c) besprochen.) In der Methode fire() wird in den zuvor aufgeführten Zeilen massive Indentation Warnungen ausgegeben. Checkstyle erwartet hier eine Einrückung von 4, 6 oder 8 aber findet 8, 12 oder 16 vor. Das ist genau Nesting Depth welche zu hoch ist.  \\\\
        \underline{2. Hotspot: Fehlende Dokumentation}\\
        \includegraphics[width=0.95\textwidth]{Tex-Graphics/Aufgabe3-b-update.jpg} \\\\\\
        Auch hier werden zahlreiche Warnungen bezüglich der Einrückungstiefe ausgegeben. Erwartet 10, 12, 14 und findet 16 oder 20 vor. Auch hier ist die Verschachtelungstiefe zu hoch. Zudem ist eine Tiefe von 20 für eine Methode sehr hoch was genau auf die Verschachtelung von if-else-Blöcken hinweist. \\

        \underline{3. Weitere Warnungen:}\\
        1. Javadoc-Zusammenfassung fehlt $\rightarrow$ zeigt dass hier nicht gut dokumentiert wurde widerrum die Wartbarkeit und Lesbarkeit verschlechtert. (Zeile 148 ff.)\\
        2. Vor Javadoc tag '@throws' sollte eine Leerzeile stehen. (Zeile 208)\\
        3. Falsche lexikographische Reihenfolge des Imports (Zeile 17) \\
        4. Zusätzliche Trennung der Importgruppe (Zeile 14)

  \item \underline{\textbf{Maßnahme 1:} Extract Method} \\
        Hier sollte eigentlich der Schaltvorgang des Bewegen der Token in einer eigenen privaten Methode ausgelagert werden. Also z.B. moveTokens(). fire() sollte auch dem Single-Responsibility Principle folgen, sie sollte also den Ablauf steuern also locking $\rightarrow$ Action $\rightarrow$ Unlocking machen, aber nicht die Details der Token-Manipulation auch noch selbst implementieren. Das erhöht z.B. die Lesbarkeit und Wartbarkeit des Codes. \\
        Die Methode fire() prüft nämlihc Bedingungen, benachrichtigt den Observer, iteriert über eingehende Stellen (also Token entfernen), iteriert über ausgehende Stellen (Token hinzufügen) und entsperrt wieder. Also vermischt die Methode fire() aktuell die Steuerung des Ablaufs mit der eigentlichen Logik (Token Bewegung) Man müsste also den Code-Block innerhalb der if-Abfrage in Zeile 10 vor allem die beiden for-Schleifen in eine eigene Methode auslagern (z.B moveTokens()). \\ \\
        \underline{Auswirkungen:} \\
        Zyklomatische Komplexität würde hierbei sinken. Beispielsweise von fire(), beide for-Schleifen würden hier in eine eigene Methode ausgelagert werden. Wir würden hierbei von unseren ursprüunglichen zyklomatischen Wert von 4 auf 2 heruntersetzen. Da hier nur noch neben dem Startwert die if-Bedingung übrig bleibt. Zudem würden die Lines of Code reduziert werden, dadurch würde sich natürlich auch die Lesbarkeit und Wartbarkeit verbessern. \\ \\
        \underline{\textbf{Maßnahme 2:} Logik vereinfachen - Verschachtelung auflösen:} \\
        update() enthält viele unnötige Verschachtelungen (nested ifs). Würden wir hier $"$else if$"$ verwenden, könnten wir die Verschachtelung reduzieren. Dies würde die Lesbarkeit und Wartbarkeit verbessern. Verschachtelte ifs sind schlecht zum lesen und schwer zu warten, vor allem wenn es immer mehr werden. Flache Strukturen hingegen sind übersichtlicher und leichter zu verstehen. Was noch besser wäre, wäre dass man die Berechnung von $"$newNoOfOccupiedPlaces$"$ auch auslagert.  \\ \\
        \underline{Auswirkungen:} \\
        Nesting depth: Die maximale Verschachtelungstiefe würde sich reduzieren, wenn wir auslagern. Die Zyklomatische Komplexität würde sich hier auch ebenfalls reduzieren, da weniger Pfade durch die Methode führen. Die Zyklomatische Komplexität von update() würde sich von 3 auf 1 reduzieren, da wir nur noch den Startwert hätten, da wir die if und fors ausgelagert hätten.  \\\\

        Was uns auch noch aufgefallen ist, ist dass $"$incomming$"$ in der Methode fire() in Zeile 13 und 14 falsch geschrieben ist. Das kann später Auswirkungen auf die Wartbarkeit haben, da man gegebenfalls nicht mehr über $"$crtl + F$"$ die Variable finden kann. Eine konsistente Benennung ist essenziell für die Wartbarkeit, das hätte zwar aktuell keine Auswirkungen auf die Metriken, aber könnte wie gesagt zu Problemen führen.
\end{enumerate}
\end{document}
